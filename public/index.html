<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Minecraft Shader Pack Progress Report</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			padding: 20px;
			background-color: #f5f5f5;
		}
		h1 {
			font-size: 48px;
			margin-bottom: 20px;
			text-align: center;
		}
		h2 {
			font-size: 36px;
			margin-bottom: 10px;
			color: #1E90FF;
		}
        h3 {
            font-size: 28px;
            margin-bottom: 10px;
			color: #29b14d;
            
        }
        figure {
            font-size: 14px;
            text-align: center;
        }
        video {
            font-size: 14px;
            text-align: center;
        }
		p {
			font-size: 18px;
			margin-bottom: 20px;
			line-height: 1.5;
		}
		ol {
			font-size: 18px;
			margin-bottom: 20px;
			line-height: 1.5;
		}
		img {
			max-width: 100%;
			margin-bottom: 20px;
			border-radius: 10px;
			box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
		}
		.container {
			max-width: 800px;
			margin: 0 auto;
		}
		.section {
			margin-bottom: 60px;
		}
		.byline {
			font-size: 16px;
			font-style: italic;
			color: #666;
			text-align: center;
		}
		.subtitle {
			font-size: 14px;
			color: #666;
			text-align: center;
			margin-top: 10px;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>Making Minecraft Look Good</h1>

		<div class="byline">By Shahar Sandhaus, Duan Lyu, Ziqi Shi, Vincent Lee</div>
		<p class="subtitle">View this report online: <a href="https://cs184.sandhaus.dev">https://cs184.sandhaus.dev</a></p>

		<div class="section">
			<h2>Abstract</h2>

			<p>For our final project in CS 184, we decided to write custom shaders for the game Minecraft. By using a popular mod for the game called <a href="https://www.optifine.net/home">Optifne</a> we where able to create a "shader pack", which is a collection of GLSL vertex and fragment shaders that are used for rending the game. By modifying these GLSL shaders, we were able to significantly alter the look of certain visual effects in the game, the most complex of which are dynamic shadow mapping and a more "realistic" water rendering system. Aside from those two big changes, we also added smaller things like a wind effect for tree leaves and an option to turn on <a href="https://en.wikipedia.org/wiki/Cel_shading">cell shading</a>.</p>
		</div>

		<div class="section">
			<h2>Technical Approach</h2>

			<h3>Optifine Overview</h3>

			<p>To undersand how we implemented the following effects, it is good to undersand how the Optifine mod works. Optifine renders each frame by performing <a href="https://optifine.readthedocs.io/shaders/programs.html">a series of render passes</a>, 4 of which were modified for this project:

				<ol>
					<li><strong>Shadow Map:</strong> This is what gets run first, and as the name suggests, this is where Optifine renders the scene from the perspective of the sun and saves the data to a built in shadowmap that is accessible as a uniform in subsequent stages.</li>
					<li><strong>Gbuffers:</strong> This is where the actual terrain, entities, water, and all other meshes are rendered. In practice there are like 20 different gbuffers shaders for all different types of meshes, but the basic idea is that the input is mesh data and the output are pixels that are drawn to our colorbuffers (there are a total of 16 color buffers we can render to).</li>
					<li><strong>Composite:</strong> This is the stage where we compose our multiple color buffers into one singular color buffer. We can have up to 16 distinct composition stages, but we only needed to use one for this project.</li>
					<li><strong>Final:</strong> This is the final screen space pass where we take the final composed image and render it to the framebuffer. Post processing effects can be applied here.</li>
				</ol>
			
			</p>
			
			
			<h3>Cell Shading</h3>

			<p>The cell shader was the very fist thing we implemented, and it is very simple. The effect works by only allowing pixel brightnesses at specific discerete values. So in the code we calculate the brightness of a pixel (the magnitude of the 3d vector representing its RBG color), then clamp it to some fraction k/n where n is the number of discrete brightnesses and k is chosen to give a fraction that most closely approximates the original brightness. Then, we simply set the brightness to that value. This gives the final output an almost "cartoonish" look, that works well for some games (like <em>Borderlans</em>), but looks prety bad for Minecraft. Still, this was a good practice run, and it helped us better understand the Optifine pipeline. Here is how this effect looks:</p>

			<figure>
				<img src="cell_on.png" alt="Cell Shading Enabled">
				<figcaption>Cell Shading Enabled</figcaption>
			</figure>
			<figure>
				<img src="cell_off.png" alt="Cell Shading Disabled">
				<figcaption>Cell Shading Disabled</figcaption>
			</figure>

			<h3>Leaf Wind Effects</h3>

			<p>The next thing we implemented, was a wind effect for the leaves of trees. Again, this was a relatively simple effect to implement. The way we did it is by modifiying the vertex shader of the leaves to add a position and time dependent offset to the vertex position (technically, we modifeid the shader for all terrain blocks, but we used an if statment to run this code only for leaves). To quickly approximate a wind effect without running complex physics simulations, we used the sum of two offset sin waves at slightly different frequencies to add to each dimention of the position (giving us a total of 6 sin waves of different frequencies). Since that explanation was a bit difficult to follow, here is the code that we use for this:</p>

			<figure>
				<img src="leaf_code.png" alt="Leaf wind code">
			</figure>

			<p>Despite the very simple nature of this implementation, the final effect actually looks pretty good: (all while being very fast to calculate)</p>

			<figure>
				<video width="640" height="360" controls autoplay loop>
					<source src="./leaves.mp4" alt="Minecraft world with crude wind effect applied">
				</video>
			</figure>

			<h3>Shadow Mapping</h3>

			<p>This is where things start to get complicated. Shadow mapping is a rendering technique where the scene geomtery is rendered from the perspective of a light source, and depth information about each pixel is stored in a depth buffer. Then, in the composition stage, we can add shadows as a screen-space effect by taking the screenspace position of the pixel and it's depth, calculating that pixel's world-space position, then transforming that position to a shadow-space position. Finally, we can sample the shadow map at that position and check if the two depths match. If they do, then that pixel is exposed to the light, otherwise, it's blocked by some object. Much of the code to get this part of the implementation working was provided by the tutorial, along with code to approximate soft shadows by supersampling the shadow map and code to modify the effective "shadow space" of the image which allowed us to keep a higher resolution at areas near the player and use a smaller resolution the farther we get (this allows close up shadows to still look decent without using a MASSIVE shadowmap). </p>

			<p>However, things got far more complicated when trying to get the code to be in a presentable state. While the tutorial was a great reference point, much of the provided code was buggy and it even had <strong><em>syntax errors and typos</em></strong>. Since we only get a simple "failed to compile" error when there is a syntax error, debugging those was very painful. However, even when we got the code running there were some major issues. Mostly notably, since the lighting effect was applied in the composition stage now (instead of in the terrain fragment shader as is default), the wrong lighting effects where being applied to the sky and the players hand:</p>
			<figure>
				<video width="640" height="360" controls loop>
					<source src="sky.mp4" alt="Lighting change as camera turn towards the sun">
				</video>
				<figcaption>Bugs from the tutorial code</figcaption>
			</figure>
			
			<p>The tutorial mentioned that these bugs would be fixed in the "next part", which never got published, so we were on our own. Our first thought was to simply move all the lighting calculations to the terrain's fragment shader. This did work sort of okay for blocks, but it meant that the player's hand, the water, all entities, and other non-terrain objects were basically not effected by shadows. This looked very bad, so we needed to figure out a way to get the effect working in the composition stage. After much time debugging, we figured out that by adding extra lines of code to all the other gbuffer fragment shaders we could write proper lighting metadata to a color attachment we used for the terrain and it would apply the proper lighting for all other objects in the scene in screen space. We assume this was the solution the tutorial was referencing, but we had to figure it out for ourselves. After we did that, we got a decent looking first attempt at a shadow that looked like this:</p>

			<figure>
				<img src="ShadowMapInitial.png" alt="Minecraft world after integrating sun lighting depths.">
				<figcaption>First shadow attempt</figcaption>
			</figure>

			<p>The hard edges of the shadow were later fixed by using the supersampling metioned above, however, the big issue with this image was that the sand texture was beign washed out by "too much light". To fix this issue, we had to go into the composition shader and apply a function to the pixel brightness to reduce how often a pixel exceeds the dynamic range of the screen. After a lot of fiddling, we ended up using the function <em> brightness = min(brightness, 3.0)*0.75</em>, since it seemed to give the best results (subjectively). Here is what that looks like:</p>

			<figure>
				<img src="FinalDiffuse.png" alt="Shadows with shadow map distortion.">
				<figcaption>Final shadow implementation</figcaption>
			</figure>

			<h3>Fancy Water</h3>

			<p>The final part of our project was to implement a shader to improve the look of water in Minecraft. For reference, here is what water looks like by default in minecraft: </p>

			
		</div>

		<p>Overall, we are happy with the progress we have made on our custom shader pack. we look forward to continuing to refine and improve upon these effects. In the last week, we are looking forward to explore more in realistic water shading in addition to polishing our completed diffuse lighting shader. If you want to checkout our progress so far, here is the repo: <a href="https://github.com/sharhar/CS184Shaders">https://github.com/sharhar/CS184Shaders</a></p>

		<p>Link to slides: <a href="https://docs.google.com/presentation/d/1r5H5pfFam_XR-G6DhAJwPgxq6yN9DzBNaUS2vLthXAo/edit?usp=sharing">https://docs.google.com/presentation/d/1r5H5pfFam_XR-G6DhAJwPgxq6yN9DzBNaUS2vLthXAo/edit?usp=sharing</a></p>


		<h3>Milestone Summary Video</h3>

		<figure>
			<video width="640" height="360" controls loop>
				<source src="summary.mov" alt="Milestone Summary Video">
			</video>
			<figcaption>Milestone Summary Video</figcaption>
		</figure>
	</div>
</body>

</html>